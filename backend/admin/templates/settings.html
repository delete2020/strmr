{% extends "base.html" %}

{% block title %}Settings - strmr Admin{% endblock %}

{% block content %}
<div class="page-header" style="display: flex; align-items: center; justify-content: space-between;">
    <div>
        <h1>Settings</h1>
        <p>Configure your strmr server</p>
    </div>
    <div style="display: flex; gap: 0.5rem;">
        <button class="btn btn-primary" onclick="saveAllSettings()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
            Save
        </button>
    </div>
</div>

<div id="settingsContainer">
    <!-- Settings sections will be rendered by JavaScript -->
    <div style="display: flex; align-items: center; justify-content: center; padding: 2rem;">
        <div class="spinner"></div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Global settings state
    let currentSettings = {{ settings | tojson | safe }};
    let schema = {{ schema | tojson | safe }};
    let groups = {{ groups | tojson | safe }};
    let originalSettings = JSON.parse(JSON.stringify(currentSettings));

    // Icon mapping
    const icons = {
        'server': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>',
        'download': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>',
        'search': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
        'magnet': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><path d="M22 7l-10 7L2 7"/></svg>',
        'film': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="7" x2="7" y2="7"/><line x1="2" y1="17" x2="7" y2="17"/><line x1="17" y1="17" x2="22" y2="17"/><line x1="17" y1="7" x2="22" y2="7"/></svg>',
        'database': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>',
        'folder': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
        'play-circle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>',
        'cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>',
        'upload': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>',
        'download-cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="8 17 12 21 16 17"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"/></svg>',
        'shuffle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>',
        'play': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>',
        'tv': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>',
        'layout': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>',
        'list': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
        'filter': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>',
        'monitor': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>',
    };

    function getIcon(name) {
        return icons[name] || icons['server'];
    }

    function getValue(path) {
        const keys = path.split('.');
        let val = currentSettings;
        for (const key of keys) {
            if (val === undefined || val === null) return undefined;
            val = val[key];
        }
        return val;
    }

    function setValue(path, value) {
        const keys = path.split('.');
        let obj = currentSettings;
        for (let i = 0; i < keys.length - 1; i++) {
            if (obj[keys[i]] === undefined) obj[keys[i]] = {};
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
    }

    function renderInput(fieldKey, fieldDef, value, basePath) {
        const id = `${basePath}_${fieldKey}`.replace(/\./g, '_');
        const isReadonly = fieldDef.readonly ? 'readonly' : '';

        switch (fieldDef.type) {
            case 'boolean':
                return `
                    <label class="toggle">
                        <input type="checkbox" id="${id}" ${value ? 'checked' : ''}
                               onchange="handleFieldChange('${basePath}', '${fieldKey}', this.checked)">
                        <span class="toggle-slider"></span>
                    </label>
                `;

            case 'select':
                // If value is empty/undefined but options exist, default to first option
                let selectValue = value;
                if ((value === '' || value === undefined || value === null) && fieldDef.options?.length > 0) {
                    selectValue = fieldDef.options[0];
                    // Update the data to match the displayed default
                    setTimeout(() => handleFieldChange(basePath, fieldKey, selectValue), 0);
                }
                const options = fieldDef.options.map(opt =>
                    `<option value="${opt}" ${selectValue === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                return `
                    <select class="form-select" id="${id}"
                            onchange="handleFieldChange('${basePath}', '${fieldKey}', this.value)">
                        ${options}
                    </select>
                `;

            case 'number':
                return `
                    <input type="number" class="form-input" id="${id}"
                           value="${value || 0}" ${isReadonly}
                           onchange="handleFieldChange('${basePath}', '${fieldKey}', parseFloat(this.value) || 0)">
                `;

            case 'password':
                return `
                    <input type="password" class="form-input" id="${id}"
                           value="${value || ''}" ${isReadonly}
                           onchange="handleFieldChange('${basePath}', '${fieldKey}', this.value)">
                `;

            case 'tags':
                const tags = Array.isArray(value) ? value : [];
                const tagsHtml = tags.map(tag =>
                    `<span class="tag">${tag}<span class="tag-remove" onclick="removeTag('${basePath}', '${fieldKey}', '${tag}')">&times;</span></span>`
                ).join('');
                return `
                    <div class="tags-input" id="${id}_container">
                        ${tagsHtml}
                        <input type="text" placeholder="Add tag..."
                               onkeydown="handleTagInput(event, '${basePath}', '${fieldKey}')">
                    </div>
                `;

            default: // text
                return `
                    <input type="text" class="form-input" id="${id}"
                           value="${value || ''}" ${isReadonly}
                           onchange="handleFieldChange('${basePath}', '${fieldKey}', this.value)">
                `;
        }
    }

    function handleFieldChange(basePath, fieldKey, value) {
        const fullPath = basePath ? `${basePath}.${fieldKey}` : fieldKey;
        setValue(fullPath, value);
    }

    function handleArrayFieldChange(basePath, index, fieldKey, value) {
        const arr = getValue(basePath);
        if (arr && arr[index]) {
            arr[index][fieldKey] = value;
        }
    }

    function handleTagInput(event, basePath, fieldKey) {
        if (event.key === 'Enter' || event.key === ',') {
            event.preventDefault();
            const input = event.target;
            const tag = input.value.trim();
            if (tag) {
                addTag(basePath, fieldKey, tag);
                input.value = '';
            }
        }
    }

    function addTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? `${basePath}.${fieldKey}` : fieldKey;
        let tags = getValue(fullPath) || [];
        if (!tags.includes(tag)) {
            tags.push(tag);
            setValue(fullPath, tags);
            renderSettings();
        }
    }

    function removeTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? `${basePath}.${fieldKey}` : fieldKey;
        let tags = getValue(fullPath) || [];
        tags = tags.filter(t => t !== tag);
        setValue(fullPath, tags);
        renderSettings();
    }

    function addArrayItem(sectionKey) {
        const sectionDef = schema[sectionKey];
        let arr;

        if (sectionDef.parent) {
            arr = currentSettings[sectionDef.parent][sectionDef.key] || [];
            currentSettings[sectionDef.parent][sectionDef.key] = arr;
        } else {
            arr = currentSettings[sectionKey] || [];
            currentSettings[sectionKey] = arr;
        }

        // Create new item with defaults
        const newItem = {};
        for (const [fieldKey, fieldDef] of Object.entries(sectionDef.fields)) {
            switch (fieldDef.type) {
                case 'boolean': newItem[fieldKey] = false; break;
                case 'number': newItem[fieldKey] = 0; break;
                case 'select': newItem[fieldKey] = fieldDef.options?.[0] || ''; break;
                default: newItem[fieldKey] = '';
            }
        }
        arr.push(newItem);
        renderSettings();
    }

    function removeArrayItem(sectionKey, index) {
        const sectionDef = schema[sectionKey];
        let arr;

        if (sectionDef.parent) {
            arr = currentSettings[sectionDef.parent][sectionDef.key];
        } else {
            arr = currentSettings[sectionKey];
        }

        if (arr && arr.length > index) {
            arr.splice(index, 1);
            renderSettings();
        }
    }

    function renderArraySection(sectionKey, sectionDef) {
        let items;
        let basePath;

        if (sectionDef.parent) {
            items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
            basePath = `${sectionDef.parent}.${sectionDef.key}`;
        } else {
            items = currentSettings[sectionKey] || [];
            basePath = sectionKey;
        }

        // Special handling for home shelves - move enabled toggle to header
        const isShelvesSection = sectionKey === 'homeShelves.shelves';

        const itemsHtml = items.map((item, index) => {
            // Filter out 'enabled' field for shelves - it goes in header
            const fieldsToRender = Object.entries(sectionDef.fields).filter(([fieldKey]) => {
                if (isShelvesSection && fieldKey === 'enabled') return false;
                return true;
            });

            const fieldsHtml = fieldsToRender.map(([fieldKey, fieldDef]) => `
                <div class="form-group">
                    <label class="form-label">${fieldDef.label}</label>
                    ${renderInput(fieldKey, fieldDef, item[fieldKey], `${basePath}.${index}`)}
                    ${fieldDef.description ? `<p class="form-hint">${fieldDef.description}</p>` : ''}
                </div>
            `).join('');

            // For shelves, add enabled toggle after delete button in header
            const enabledToggleHtml = isShelvesSection && sectionDef.fields.enabled ? `
                <label class="toggle" style="margin-left: 0.5rem;">
                    <input type="checkbox" ${item.enabled ? 'checked' : ''}
                           onchange="handleArrayFieldChange('${basePath}', ${index}, 'enabled', this.checked); renderSettings();">
                    <span class="toggle-slider"></span>
                </label>
            ` : '';

            return `
                <div class="array-item">
                    <div class="array-item-header">
                        <div class="array-item-title">
                            ${item.name || item.id || `Item ${index + 1}`}
                        </div>
                        <div class="array-item-actions" style="display: flex; align-items: center; gap: 0.5rem;">
                            <button class="btn btn-sm btn-danger" onclick="removeArrayItem('${sectionKey}', ${index})">
                                <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                </svg>
                            </button>
                            ${enabledToggleHtml}
                        </div>
                    </div>
                    <div class="grid grid-2">
                        ${fieldsHtml}
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="array-items">
                ${itemsHtml}
                <button class="add-item-btn" onclick="addArrayItem('${sectionKey}')">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add ${sectionDef.label.replace(/s$/, '')}
                </button>
            </div>
        `;
    }

    function renderObjectSection(sectionKey, sectionDef) {
        const sectionData = currentSettings[sectionKey] || {};

        return Object.entries(sectionDef.fields).map(([fieldKey, fieldDef]) => `
            <div class="form-group">
                <label class="form-label">${fieldDef.label}</label>
                ${renderInput(fieldKey, fieldDef, sectionData[fieldKey], sectionKey)}
                ${fieldDef.description ? `<p class="form-hint">${fieldDef.description}</p>` : ''}
            </div>
        `).join('');
    }

    function renderSection(sectionKey, sectionDef) {
        const isOpen = window.location.hash === `#${sectionKey}`;
        const contentHtml = sectionDef.is_array
            ? renderArraySection(sectionKey, sectionDef)
            : `<div class="grid grid-2">${renderObjectSection(sectionKey, sectionDef)}</div>`;

        // Check if there are nested array sections (only those without their own group)
        let nestedHtml = '';
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                nestedHtml += `
                    <div style="margin-top: 1.5rem;">
                        <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.75rem;">
                            ${nestedDef.label}
                        </h3>
                        ${renderArraySection(nestedKey, nestedDef)}
                    </div>
                `;
            }
        }

        return `
            <div class="section ${isOpen ? 'open' : ''}" id="section-${sectionKey}">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title">
                        ${getIcon(sectionDef.icon)}
                        ${sectionDef.label}
                    </div>
                    <svg class="section-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"/>
                    </svg>
                </div>
                <div class="section-content">
                    ${contentHtml}
                    ${nestedHtml}
                </div>
            </div>
        `;
    }

    function renderSettings() {
        const container = document.getElementById('settingsContainer');

        // Render sections grouped by their group property
        // Sections with their own group are shown at top level, even if they have a parent (for data access)
        let html = '';
        for (const group of groups) {
            const groupSections = Object.entries(schema)
                .filter(([key, def]) => def.group === group.id)
                .sort((a, b) => (a[1].order ?? 999) - (b[1].order ?? 999));

            if (groupSections.length === 0) continue;

            html += `<div class="settings-group">
                <h2 class="group-title">${group.label}</h2>
                <div class="group-sections">
                    ${groupSections.map(([key, def]) => renderSection(key, def)).join('')}
                </div>
            </div>`;
        }

        container.innerHTML = html;

        // Handle hash navigation
        if (window.location.hash) {
            const sectionId = window.location.hash.substring(1);
            const section = document.getElementById(`section-${sectionId}`);
            if (section) {
                section.classList.add('open');
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
    }

    async function saveAllSettings() {
        try {
            const result = await apiCall('/api/settings', 'PUT', currentSettings);
            if (result.success) {
                originalSettings = JSON.parse(JSON.stringify(currentSettings));
                showToast('Settings saved successfully');
            } else {
                showToast(result.error || 'Failed to save settings', 'error');
            }
        } catch (e) {
            showToast('Failed to save settings: ' + e.message, 'error');
        }
    }

    function resetSettings() {
        if (confirm('Reset all changes? This will revert to the last saved settings.')) {
            currentSettings = JSON.parse(JSON.stringify(originalSettings));
            renderSettings();
            showToast('Settings reset to last saved state');
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        renderSettings();
    });

    // Handle hash changes
    window.addEventListener('hashchange', () => {
        const hash = window.location.hash.substring(1);
        if (hash) {
            const section = document.getElementById(`section-${hash}`);
            if (section) {
                // Close all sections
                document.querySelectorAll('.section').forEach(s => s.classList.remove('open'));
                // Open target section
                section.classList.add('open');
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
    });
</script>
{% endblock %}
